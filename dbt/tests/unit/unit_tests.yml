# dbt Unit Tests
# 
# Unit tests validate the SQL logic of your models in isolation,
# without requiring actual data in the warehouse.
# 
# This is a dbt 1.8+ feature that follows test-driven development (TDD)
# principles for data transformations.
#
# Run with: dbt test --select "test_type:unit"

version: 2

unit_tests:
  # ===================
  # STAGING MODEL TESTS
  # ===================
  
  # Test: stg_iot_events battery status classification
  - name: test_stg_iot_events_battery_status
    description: "Verify battery_status is correctly derived from battery_level"
    model: stg_iot_events
    given:
      - input: source('bronze', 'iot_events')  # Mock the source
        rows:
          - {event_id: "evt-001", device_id: "dev-001", battery_level: 15, timestamp: "2025-01-01 10:00:00", sensor_type: "temperature", value: 25.5, unit: "celsius", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0.0"}
          - {event_id: "evt-002", device_id: "dev-002", battery_level: 35, timestamp: "2025-01-01 10:00:00", sensor_type: "humidity", value: 60.0, unit: "percent", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0.0"}
          - {event_id: "evt-003", device_id: "dev-003", battery_level: 55, timestamp: "2025-01-01 10:00:00", sensor_type: "pressure", value: 1013.0, unit: "hPa", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0.0"}
          - {event_id: "evt-004", device_id: "dev-004", battery_level: 85, timestamp: "2025-01-01 10:00:00", sensor_type: "motion", value: 1, unit: "boolean", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0.0"}
    expect:
      rows:
        - {event_id: "evt-001", battery_status: "critical"}  # < 20%
        - {event_id: "evt-002", battery_status: "low"}       # < 40%
        - {event_id: "evt-003", battery_status: "medium"}    # < 60%
        - {event_id: "evt-004", battery_status: "good"}      # >= 60%

  # Test: stg_iot_events quality flag validation
  - name: test_stg_iot_events_is_valid_reading
    description: "Verify is_valid_reading is TRUE only for 'good' quality_flag"
    model: stg_iot_events
    given:
      - input: source('bronze', 'iot_events')
        rows:
          - {event_id: "evt-001", device_id: "dev-001", quality_flag: "good", battery_level: 50, timestamp: "2025-01-01", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", firmware_version: "1.0"}
          - {event_id: "evt-002", device_id: "dev-002", quality_flag: "suspect", battery_level: 50, timestamp: "2025-01-01", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", firmware_version: "1.0"}
          - {event_id: "evt-003", device_id: "dev-003", quality_flag: "anomaly", battery_level: 50, timestamp: "2025-01-01", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", firmware_version: "1.0"}
    expect:
      rows:
        - {event_id: "evt-001", is_valid_reading: true}
        - {event_id: "evt-002", is_valid_reading: false}
        - {event_id: "evt-003", is_valid_reading: false}

  # ===================
  # CDC TRANSFORMATION TESTS
  # ===================
  
  # Test: stg_devices correctly handles CDC operations
  - name: test_stg_devices_cdc_operations
    description: "Verify CDC operations are correctly interpreted"
    model: stg_devices
    given:
      - input: ref('cdc_devices')
        rows:
          # Initial read
          - {device_id: "dev-001", device_name: "Sensor A", __op: "r", __deleted: false, created_at: "2025-01-01"}
          # Create
          - {device_id: "dev-002", device_name: "Sensor B", __op: "c", __deleted: false, created_at: "2025-01-02"}
          # Update
          - {device_id: "dev-003", device_name: "Sensor C Updated", __op: "u", __deleted: false, created_at: "2025-01-01"}
          # Delete (should be filtered out)
          - {device_id: "dev-004", device_name: "Deleted Sensor", __op: "d", __deleted: true, created_at: "2025-01-01"}
    expect:
      rows:
        - {device_id: "dev-001", is_deleted: false}
        - {device_id: "dev-002", is_deleted: false}
        - {device_id: "dev-003", is_deleted: false}
        # dev-004 should NOT appear (filtered by __deleted = true)

  # ===================
  # AGGREGATION TESTS
  # ===================
  
  # Test: fct_iot_events_hourly aggregation logic
  - name: test_fct_iot_events_hourly_aggregation
    description: "Verify hourly aggregations are calculated correctly"
    model: fct_iot_events_hourly
    given:
      - input: ref('stg_iot_events')
        rows:
          - {event_id: "evt-001", device_id: "dev-001", event_timestamp: "2025-01-01 10:15:00", sensor_type: "temperature", sensor_value: 20.0, is_valid_reading: true}
          - {event_id: "evt-002", device_id: "dev-001", event_timestamp: "2025-01-01 10:30:00", sensor_type: "temperature", sensor_value: 22.0, is_valid_reading: true}
          - {event_id: "evt-003", device_id: "dev-001", event_timestamp: "2025-01-01 10:45:00", sensor_type: "temperature", sensor_value: 24.0, is_valid_reading: true}
          - {event_id: "evt-004", device_id: "dev-001", event_timestamp: "2025-01-01 10:50:00", sensor_type: "temperature", sensor_value: 100.0, is_valid_reading: false}  # Bad reading
    expect:
      rows:
        - device_id: "dev-001"
          hour_start: "2025-01-01 10:00:00"
          sensor_type: "temperature"
          avg_value: 22.0          # Average of 20, 22, 24 (excluding bad reading)
          min_value: 20.0
          max_value: 24.0
          reading_count: 3         # Only valid readings
          anomaly_count: 1         # The bad reading

  # ===================
  # DIMENSION TESTS
  # ===================
  
  # Test: dim_devices surrogate key generation
  - name: test_dim_devices_surrogate_key
    description: "Verify device_key is consistently generated"
    model: dim_devices
    given:
      - input: ref('stg_devices')
        rows:
          - {device_id: "dev-001", device_name: "Sensor A", device_type: "temperature", is_active: true}
          - {device_id: "dev-002", device_name: "Sensor B", device_type: "humidity", is_active: false}
    expect:
      # device_key should be a hash of device_id
      rows:
        - {device_id: "dev-001", is_current: true}
        - {device_id: "dev-002", is_current: true}

  # ===================
  # EDGE CASE TESTS
  # ===================
  
  # Test: Handle NULL values gracefully
  - name: test_stg_iot_events_null_handling
    description: "Verify NULL values are handled correctly"
    model: stg_iot_events
    given:
      - input: source('bronze', 'iot_events')
        rows:
          - {event_id: "evt-001", device_id: "dev-001", battery_level: null, timestamp: "2025-01-01", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", quality_flag: "good", firmware_version: null}
    expect:
      rows:
        - event_id: "evt-001"
          # NULL battery should result in some default behavior
          battery_status: "good"  # Assuming default when NULL

  # Test: Duplicate event handling
  - name: test_stg_iot_events_deduplication
    description: "Verify duplicate events are handled by unique key"
    model: stg_iot_events
    given:
      - input: source('bronze', 'iot_events')
        rows:
          # Same event_id - should dedupe
          - {event_id: "evt-001", device_id: "dev-001", battery_level: 50, timestamp: "2025-01-01 10:00:00", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0", _ingested_at: "2025-01-01 10:01:00"}
          - {event_id: "evt-001", device_id: "dev-001", battery_level: 50, timestamp: "2025-01-01 10:00:00", sensor_type: "temperature", value: 25, unit: "celsius", location_id: "loc-001", quality_flag: "good", firmware_version: "1.0", _ingested_at: "2025-01-01 10:02:00"}  # Later ingestion
    expect:
      # Should only have one row (latest ingestion)
      rows:
        - event_id: "evt-001"
